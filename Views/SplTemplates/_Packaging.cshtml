@using MedRecPro.Models;
@using MedRecPro.Helpers;
@inherits RazorLight.TemplatePage<MedRecPro.Models.PackageRendering>;
@model PackageRendering;

@* CORRECTED: Template using only existing DTO properties *@
@if (Model != null && Model.HasValidData)
{
    var packagingModel = Model.PackagingLevelDto;
    <asContent>
        @* Render quantity section with proper numerator translations *@
        @if (Model.HasQuantity)
        {
            <quantity>
                <numerator @SplTemplateHelpers.Attribute("value", Model.FormattedQuantityNumerator)></numerator>
                <denominator @SplTemplateHelpers.Attribute("value", Model.FormattedQuantityDenominator)></denominator>
            </quantity>
        }
        <containerPackagedProduct>
            @* Render only NDCs that match this packaging level's PackagingLevelID *@
            @if (Model.HasPackageIdentifiers && Model.OrderedPackageIdentifiers != null)
            {
                foreach (var identifier in Model.OrderedPackageIdentifiers)
                {
                    <code @SplTemplateHelpers.Attribute("code", identifier.IdentifierValue) @SplTemplateHelpers.Attribute("codeSystem", identifier.IdentifierSystemOID) @SplTemplateHelpers.Attribute("codeSystemName", identifier.IdentifierType ?? "NDC") />
                }
            }
            else
            {
                <code />
            }
            @* Render form code using existing DTO properties *@
            @if (Model.HasFormCode)
            {
                <formCode @SplTemplateHelpers.Attribute("code", Model.PackageFormCode) @SplTemplateHelpers.Attribute("codeSystem", Model.PackageFormCodeSystem) @SplTemplateHelpers.Attribute("displayName", Model.PackageFormDisplayName) />
            }
            @* Render nested child packaging using existing ChildPackagingLevel *@
            @if (Model.HasChildPackageRendering && Model.ChildPackageRendering != null)
            {
                foreach (var childPackage in Model.ChildPackageRendering)
                {
                    @* Recursive inclusion creates proper nested <asContent> structure *@
                    await IncludeAsync("_Packaging", childPackage);
                }
            }
        </containerPackagedProduct>
        @if (Model.HasMarketing)
        {
            foreach (var marketing in Model.PackagingLevelDto.MarketingStatuses)
            {
                <subjectOf>
                    <marketingAct>
                        <code @SplTemplateHelpers.Attribute("code", marketing.MarketingActCode) @SplTemplateHelpers.Attribute("codeSystem", marketing.MarketingActCodeSystem)  />
                        <statusCode @SplTemplateHelpers.Attribute("code", marketing.StatusCode) />
                        <effectiveTime>
                            @if (marketing.EffectiveStartDate.HasValue)
                            {
                                <low @SplTemplateHelpers.Attribute("value", SplTemplateHelpers.ToSplDate(marketing.EffectiveStartDate)) />
                            }
                            @if (marketing.EffectiveEndDate.HasValue)
                            {
                                <high @SplTemplateHelpers.Attribute("value", SplTemplateHelpers.ToSplDate(marketing.EffectiveEndDate)) />
                            }
                        </effectiveTime>
                    </marketingAct>
                </subjectOf>
            }
        }
    </asContent>
}